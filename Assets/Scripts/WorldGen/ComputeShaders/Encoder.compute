#pragma kernel NoiseGenerator
#include "noiseSimplex.cginc"

// data buffers
RWStructuredBuffer<float> HtoTCurveSample;
RWStructuredBuffer<float4> BiomeColors;

// first iteration output
RWTexture2D<float4> ContinentMap;
RWTexture2D<float4> Altitude;
RWTexture2D<float4> Proximity;

// second iteration output
RWTexture2D<float4> Temperature;
RWTexture2D<float4> Humidity;
RWTexture2D<float4> Elevation;

// final output
RWTexture2D<float4> BiomeMap;

// texture and base noise settings
int randSeed1;
int randSeed2;
int randSeed3;
int randSeed4;
int width;
int height;
int octaves;
int scale;
float gain;
float lacunarity;

// generator settings
int altitudeScale;
int altitudeAmplitude;

float HtoTCurveRes;
float AtoTWeight;
float AtoHWeight;


float remap(float v, float minOld, float maxOld, float minNew, float maxNew) {
    return saturate(minNew + (v-minOld) * (maxNew - minNew) / (maxOld-minOld));
}

float3 latLongToPoint(float latitude, float longitude) {

    float y = sin(latitude);
    float r = cos(latitude); // radius of 2d circle cut through sphere at 'y'
    float x = sin(longitude) * r; 
    float z = -cos(longitude) * r;

    return float3(x, y, z);
}

float fbm(float3 x)
{
    float value = 0.0;
    float amplitude = 1;
    float frequency = 1;
    
    for (int i = 0; i < octaves; i++) {
        
        value += amplitude * snoise(frequency * x);
        x *= 2.;
        amplitude *= gain;
        frequency *= lacunarity;
    }
    return value;
}

[numthreads(16,16,1)]
void NoiseGenerator (uint3 id : SV_DispatchThreadID)
{
    // this generate main height
    float p = 3.14159265358979323846;
    float _x = remap(id.x, 0, width, 0, 1);
    float _y = remap(id.y, 0, height, 0, 1);

    float3 v = latLongToPoint((_y * p) - p / 2, (_x * p * 2) - p) * 2048;
    float3 mainV = float3(v.x + randSeed1, v.y + randSeed1, v.z + randSeed1);
    float3 subV = float3(v.x + randSeed2 + 100, v.y + randSeed2 + 100, v.z + randSeed2 + 100);
    
    float h = (fbm(mainV / scale) + 1) / 2;
    float subH = (fbm(subV / (scale / 2)) + 1) / 2;
    
    float h0 = step(0.6, h);
    float subH0 = step(0.8, subH);
    
    float f = 0;
    
    if (h0 > 0.99) { f = remap(h, 0.6, 1, 0, 1);}
    else if (subH0 > 0.99) { f = remap(subH, 0.8, 1, 0, 1);}

    float4 d0 = float4(f, f, f, 1);
    NoiseMap[id.xy] = d0;
}


