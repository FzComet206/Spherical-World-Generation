#pragma kernel NoiseGenerator
#pragma kernel BiomeGenerator
#include "noiseSimplex.cginc"

// data buffers
RWStructuredBuffer<float> HtoTCurveSample;
RWStructuredBuffer<float4> BiomeColors;

// first iteration output
RWTexture2D<float4> ContinentMap;
RWTexture2D<float4> Altitude;
RWTexture2D<float4> Proximity;
RWTexture2D<float4> Elevation;

// second iteration output
RWTexture2D<float4> Temperature;
RWTexture2D<float4> Humidity;

// final output
RWTexture2D<float4> BiomeMap;

// texture and base noise settings
int randSeed1;
int randSeed2;
int randSeed3;
int randSeed4;
int width;
int height;
int octaves;
int scale;
float gain;
float lacunarity;

// generator settings
int altitudeScale;
int altitudeAmplitude;

int HtoTCurveRes;
float AtoTWeight;
float AtoHWeight;

float remap(float v, float minOld, float maxOld, float minNew, float maxNew) {
    return saturate(minNew + (v-minOld) * (maxNew - minNew) / (maxOld-minOld));
}

float3 latLongToPoint(float latitude, float longitude) {

    float y = sin(latitude);
    float r = cos(latitude); // radius of 2d circle cut through sphere at 'y'
    float x = sin(longitude) * r; 
    float z = -cos(longitude) * r;

    return float3(x, y, z);
}

float fbm(float3 x)
{
    float value = 0.0;
    float amplitude = 1;
    float frequency = 1;
    
    for (int i = 0; i < octaves; i++) {
        
        value += amplitude * snoise(frequency * x);
        x *= 2.;
        amplitude *= gain;
        frequency *= lacunarity;
    }
    return value;
}

[numthreads(16,16,1)]
void NoiseGenerator (uint3 id : SV_DispatchThreadID)
{
    // this generate main height
    float p = 3.14159265358979323846;
    float _x = remap(id.x, 0, width - 1, 0, 1);
    float _y = remap(id.y, 0, height - 1, 0, 1);

    // forgot why i would multiply this by 2048 but whatever
    float3 v = latLongToPoint((_y * p) - p / 2, (_x * p * 2) - p) * 2048;
    
    float3 large = float3(v.x + randSeed1, v.y + randSeed1, v.z + randSeed1);
    float3 medium = float3(v.x + randSeed2, v.y + randSeed2, v.z + randSeed2);
    
    float h0 = (fbm(large / scale) + 1) / 2;
    float h1 = (fbm(medium / (scale / 3)) + 1) / 2;
    
    float clampH0 = step(0.55, h0);
    float clampH1 = step(0.7, h1); 
    
    float f0 = 0;

    float case1 = remap(h0, 0.55, 1, 0, 1);
    float case2 = remap(h1, 0.7, 1, 0, 0.6);
    float case0 = max(case1, case2);
    
    if (clampH0 > 0.99 && clampH1 > 0.99) { f0 = case0; }
    else if (clampH0 > 0.99) { f0 = case1; }
    else if (clampH1 > 0.99) { f0 = case2; }

    float f1 = step(1, clampH0 + clampH1);

    // altitude
    float3 n3 = float3(v.x + randSeed3, v.y + randSeed3, v.z + randSeed3);

    int d = id.y + fbm(n3 / altitudeScale) * altitudeAmplitude;
    float mid = (float) height / 2.;
    if (d < 0) { d += height; } else if (d > height) { d -= height; }
    float f2 = 1 - abs(d - mid) / mid;
    
    float4 d0 = float4(f0, f0, f0, 1);
    Proximity[id.xy] = d0;
    float4 d1 = float4(f1, f1, f1, 1);
    ContinentMap[id.xy] = d1;
    float4 d2 = float4(f2, f2, f2, 1);
    Altitude[id.xy] = d2;

    // computing elevation
    float3 elevationV = float3(v.x + randSeed4, v.y + randSeed4, v.z + randSeed4);
    float f3 = (fbm(elevationV / scale * 3) + 1) / 2;
    float4 d3 = float4(f3, f3, f3, 1);
    Elevation[id.xy] = d3;

    // computing temperature
    const float aToTCompliment = 1 - AtoTWeight;
    
    float proximity = Proximity[id.xy].r;
    float altitude = Altitude[id.xy].r;
    float elevation = Elevation[id.xy].r;

    // higher altitude means lower temperature
    // higher elevation means lower temperature
    // farther from sea means temperature gets multiplied 

    // altitude approach middle and proximity approach low means higher temperature
    float temperatureRaw = altitude * AtoTWeight + (1 - elevation) * aToTCompliment;

    // skew temperature toward 0 or 1 if they are away from 0.5 in case proximity is high
    // 0.7 is a fairly balanced constant
    float t =
        min(1, (1 - (0.5 - temperatureRaw)) * temperatureRaw * proximity + (1 - proximity) * temperatureRaw);
    Temperature[id.xy] = float4(t, t, t, 1);

    // altitude approach middle and proximity approach low means higher humidity
    float h =
        min(1, altitude * 0.4 + (1 - proximity) * 0.3 + (1 - elevation) * 0.3);
    Humidity[id.xy] = float4(h, h, h, 1);
}

// have to split kernels for more than 8 buffers

[numthreads(16,16,1)]
void BiomeGenerator(uint3 id : SV_DispatchThreadID)
{
    float c = ContinentMap[id.xy].r;
    float t = Temperature[id.xy].r;
    float h = Humidity[id.xy].r;
    
    // sample humidity at current temperature
    float corr = HtoTCurveSample[(int) (t * HtoTCurveRes) - 1];
    
    // logical min-terms for encoding biome
    int desert = step(0.55, t) * step(h, 0.6) * c;
    int plains = step(t, 0.55) * step(0.4, t) * step(h, 0.6) * c;
    int poles = step(t, 0.3) * step(h, corr) * step(h, 0.35) * c + step(corr, h) * c;
    
    int savanna = step(0.65, t) * step(0.6, h) * step(h, 0.75) * c;
    int rocky = step(0.45, t) * step(t, 0.65) * step(h, 0.75) * step(0.6, h) * c;
    
    // the bounds for tundra is the conjunction of three bounds
    int tundra = step(t, 0.3) * step(0.35, h) * step(h, corr) * c +
        step(0.3, t) * step(t, 0.4) * step(h, corr) * c +
            step(0.4, t) * step(t, 0.45) * step(0.6, h) * step(h, corr) * c;
    
    int forest = step(0.45, t) * step(0.75, h) * step(h, 0.86) * c;
    int rainForest = step(0.86, t) * step(0.86, h) * step(h, corr) * c;
    int swamp = step(0.45, t) * step(t, 0.86) * step(0.86, h) * step(h, corr) * c;

    float4 color =
        BiomeColors[0] * desert +
            BiomeColors[1] * plains +
                BiomeColors[2] * poles +
                BiomeColors[3] * savanna +
                    BiomeColors[4] * rocky +
                        BiomeColors[5] * tundra +
                            BiomeColors[6] * forest +
                                BiomeColors[7] * rainForest +
                                    BiomeColors[8] * swamp;
    color.a = 1;
    BiomeMap[id.xy] = color;
}

    

